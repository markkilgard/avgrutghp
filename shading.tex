% !TEX root = illustrator_submission.tex

\section{Shading}
\label{sec:shading}

\Illustrator/ supports constant color, linear gradients, radial gradients, and raster shading.
These straightforward shading modes are performed by ``cover'' fragment shaders
much as described by \cite{KilgardBolz2012} with short shaders.  The shaders must be tweaked
to support outputting to NChannel framebuffers but are otherwise not particularly noteworthy.
PDF's support for patterns and gradient meshes however present more interesting shading challenges.

\subsection{Patterns}
\label{sec:patterns}

A {\em pattern} consists of a small graphical figure called a pattern cell,
which is replicated at fixed horizontal and vertical intervals to
fill an area.  This process is called {\em tiling} the area.  The pattern cell
comprises graphical elements (such as paths, text, and images), may
be non-rectangular in shape, and the spacing of tiles can differ from
the dimensions of the cell itself.  To draw a pattern, the pattern cell
is drawn as many times as necessary to fill the given area.  We accomplish
this in one of two methods:
\begin{enumerate}

\item If a pattern object contains a non-isolated group with a blend
mode, the contents of a pattern cell are drawn at each step, clipped to
the tile area.

\item Otherwise, the contents of the pattern cell are drawn once into a
separate texture (which is of the same size as pattern cell), and this
texture is copied at each tile location.

\end{enumerate}

The actual process of clipping to a tile is the same method described by \cite{KilgardBolz2012}
to clip to an arbitrary path.

\subsection{Gradient Meshes} 
\label{sec:gradient-meshes}

The PDF specification provide several mesh-based shading techniques for vector objects:
\begin{itemize}
\item Free-form and lattice-form smooth shaded triangle meshes,
\item Coons patch \cite{CoonsPaper} meshes, and
\item Tensor-product patch meshes.
\end{itemize}

Triangle meshes are fairly straightforward as the GPU is excellent at rendering smooth-shaded color triangles.
The only caveats are we stencil test these triangles against the shaded object's stenciled region and use
a final ``cover'' step but with color writes disabled to make sure the stenciled region is reset.

\ifdefined\NOSHOW
\subsubsection{Triangle Meshes}

Shading by triangle meshes, whether free-form or lattice-form,
is straightforward to implement on the GPU.  The meshes are simply transformed and rasterized
as triangles with {\em smooth} (or PDF also supports {\em flat}) color interpolation.  Stencil testing against coverage generated by the ``stencil'' step
of ``stencil, then cover'' path rendering ensures the shading stays within the path object's stroked or filled coverage.
If the triangles in the mesh overlap, the last triangle to cover a color sample position decides that sample's color (no double blending allowed).  The most efficient way to accomplish this is rendering the mesh triangles in reverse and having
the stencil operation reset the stencil value when the stencil test passes and the sample's color is updated.  This
is more efficient since no color sample is updated by the triangle mesh more than once.  The mesh may not
cover all color samples within the region stenciled by the ``stencil'' step; to remedy this, a final ``cover'' step that simply resets
the stencil values to their neutral state (but not update the color buffer) when the stencil test passes
will ensure all 
stencil values within the path's stenciled region are reset.  Modern GPUs optimize for high stencil discard rates
so this extra ``cover'' step is inexpensive.
\fi

Patch meshes are more challenging than triangle meshes as edges of the patches are bicubic B\'{e}zier segments and the patch may fold over itself.  The na\"{\i}ve approach would expand the patch into a triangle mesh and render in the same manner as the shaded triangle meshes.  This has the disadvantage that a sufficiently tessellated triangle mesh to approximate each patch in a patch mesh (which might be hundreds of patches) is expensive for the CPU to generate and store.  Having to CPU-tessellate all the patches undermines the compactness and editability advantages of Coons patches.  Moreover the tessellated triangle meshes would be resolution-dependent so would not support fast zooming of the scene.

Fortunately modern GPUs support hardware tessellation units \cite{schaefer2014star}, but the application
of this hardware is primarily directed at depth-tested 3D models formed from tessellated patches.

We harness this same tessellation hardware to render PDF's Coons and tensor-product patch meshes, but we
identify some limitations of existing GPU hardware applied to our 2D tessellation task.
Hardware tessellation splits the process of rasterizing patches into
three programmable domains:
\begin{description}
\item[Vertex shading] facilitating the transformation of control points from object space to other spaces.
\item[Tessellation Control shading] accepting an array of control points (transformed by vertex shading) and outputting a fixed (possibly different) number
of control points, uniform patch values, and level-of-detail parameters to define a patch to evaluate.
\item[Tessellation Evaluation shading] evaluating the patch output from the tessellation control shader at a given ($u$,$v$) location within the patch as part of a mesh topology generated by fixed-function hardware.
\end{description}
At first glance, this hardware is readily amenable to tessellation of our 2D gradient mesh patches.
The vertex shader can transform vertices from object space into window-space.  The Tessellation Control Shader (TCS)
subsequently performs
a basis change from a Coons patch to a bicubic B\'{e}zier basis for ease of evaluation by the Tessellation Evaluation Shader (TES); the tensor-product patch is already a B\'{e}zier bicubic.  The TCS uses the window-space control point positions to compute
appropriate level-of-detail parameters to ensure every triangle in the tessellated topology is on the scale of about 1 to 2 pixels to minimize under or over tessellation.
The TES should evaluate the 2D position at its ($u$,$v$)
and interpolate a color based on color values assigned to the corner control points.  Still there are three
notable issues to address.

\paragraph{Resolving Mesh Overlap Render Order}

First GPU hardware tessellation does not guarantee the precise triangle
rasterization order for a patch.  This is justified because 1) 3D models are expected to be depth-tested to resolve hidden surface occlusion so there is no mandatory intra-patch triangle ordering (though the order is reasonably expected to
be deterministic); and 2) the hardware is more efficient if it can group vertices into triangles to maximize
vertex reuse.  However PDF mandates a particular order:
\begin{quote}
\small
Patches can sometimes appear to fold over on themselves---for example, if a boundary curve intersects itself. 
As the value of parameter $u$ or $v$ increases in parameter space, the location of the corresponding pixels in 
device space may change direction so that new pixels are mapped onto previous pixels already mapped. If 
more than one point ($u$, $v$) in parameter space is mapped to the same point in device space, the point selected 
shall be the one with the largest value of $v$. If multiple points have the same $v$, the one with the largest value of 
$u$ shall be selected. If one patch overlaps another, the patch that appears later in the data stream shall paint 
over the earlier one. 
\cite{PDF-Spec} \S 8.7.4.5.7
\end{quote}
This provides a tidy, well-defined order but does not match the actual hardware rendering order.
To resolve this, a combination of ($u$,$v$) and the current patch number
(indicated by {\tt gl\_InvocationID}) can be combined into a [0,1] value to use as a depth value.  For example:
\begin{verbatim}
  gl_Position.z = float(gl_InvocationID*65536
    + int(v*255)*256 + int(u*255))/ 16777215.0;
\end{verbatim}
Larger magnitude depth values are later in the rendering order.  When the gradient mesh is opaque such that
double blending is not a concern, depth buffering with a {\tt GL\_GREATER} depth buffer is sufficient to ensure
the gradient patch mesh ordering.  If that is not the case, a depth-only rendering pass to resolve the last
update to every color sample followed by a second {\tt GL\_EQUAL} depth function pass to assign interpolated color
and blend is necessary.

While we understand it is only the ordering of rasterized triangles within a patch that is implementation-dependent,
one or more patches may overlap a color sample so depth samples from different patches always compare with the latter patch in render order ``winning''.

Prior to rendering any set of patches, a depth clear to zero is necessary to reset the depth buffer.  This could
be done with a ``cover'' operation that simply zeros the depth buffer (without modifying other buffers) or with
a scissored depth buffer clear.
%{\tt glClear(GL\_DEPTH\_BUFFER\_BIT)}.

Once the render order issues are resolved, color shading is a matter of bicubic interpolation \cite{Sun:2007:IVU:1276377.1276391} in the TES.

This is a lot of complexity to match the PDF specification's patch rendering order.  Certainly if the hardware's
tessellation generator simply guaranteed an order consistent with the PDF specification, even at the cost of some
less optimal hardware efficiency, rendering PDF gradient meshes would be much more straightforward.

Another option is detecting via CPU preprocessing of the patch mesh whether or not actual mesh overlaps are present \cite{Randrianarivony04necessaryand}.
When not present, gradient mesh rendering could be much more straightforward and efficient.  In practice,
we know overlaps are rare in real gradient mesh content.

\ifdefined\NOSHOW

\paragraph{Assigning Colors to Patch Corners}

The Coons patch has twelve positional 2D control points while the tensor-product patch has sixteen.
But both Coons and tensor-product patches have just four colors, one for each patch corner.
In conventional triangle meshes, so-called {\em per-vertex} color attributes are assigned at every vertex position.
In the gradient mesh case, color values are assigned at just one-third or one-quarter the frequency of control points.

It is undesirable to assign colors for every control point vertex.  It both requires more static storage and
requires pulling vertex attributes for color that go unused.

\begin{figure}[tb]
  \center{\includegraphics[width=2.7in]{images/gradientmesh.pdf}}
  \caption{\label{fig:gradient-mesh}
Single gradient mesh patch showing 12 patch (x,y) control points of Coons patch
and 4 corner colors, where pairs of
control points provide the red-green and blue-alpha components.}
\end{figure}

Instead we segregate our vertex index values into two ranges, one for positions and one for colors with
a boundary index $b$.  Vertex index values below $b$ are positions and at or above are colors.  The vertex
shader transforms positions to window space while passing color components unmodified.  This allows
a single vertex attribute arrays indexing ($x$,$y$) values to interpret those values as either positions
or pairs of color components.  

Figure~\ref{fig:gradient-mesh} shows a Coons path with twenty control points
arriving in a TCS which treats the first twelve control points as 2D positions while the subsequent eight control
points make up the {\em red-green} and {\em blue-alpha} components of RGBA colors.  The advantage of this
approach is that positions and colors can be stored in a single buffer for efficient updating.  Extending
this to tensor-product patches or CMYK colors simply adds more control points for the additional data
and modify the TCS appropriately.
\fi

\paragraph{Coarse Level-of-detail Control}

Graphics hardware tessellation has a limited maximum level-of-detail for tessellation.  When the level-of-detail
is clamped to a hardware limit for tessellation, tessellation artifacts may arise.  We monitor the relative
size of tessellated patches such that their maximum level-of-detail does not grossly exceed the scale of two or three pixels
in window space.  If this happens, patches need to be subdivided manually to ensure the patch mesh
avoids objectionable tessellation artifacts.  Care is necessary to maintain a water-tight subdivided patch mesh.  This is done by ensuring exactly matching level-of-detail computations on mutual edges of adjacent patches.



 
